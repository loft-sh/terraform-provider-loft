//// Code generated by go-swagger; DO NOT EDIT.

package schemas

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	storagev1 "github.com/loft-sh/api/v2/pkg/apis/storage/v1"
	"github.com/loft-sh/terraform-provider-loft/pkg/utils"
)

func StorageV1ArgoProjectSpecSchema() map[string]*schema.Schema {
	return map[string]*schema.Schema{
		"enabled": {
			Type:        schema.TypeBool,
			Description: "Enabled indicates if the ArgoCD Project Integration is enabled for this project. Enabling this will cause Loft to create an appProject in ArgoCD that is associated with the Loft Project. When Project integration is enabled Loft will override the default assigned role set in the SSO integration spec.",
			Optional:    true,
		},
		"metadata": {
			Type:     schema.TypeList,
			MinItems: 1,
			MaxItems: 1,
			Elem: &schema.Resource{
				Schema: StorageV1ArgoProjectSpecMetadataSchema(),
			},
			Description: "Metadata defines additional metadata to attach to the loft created project in ArgoCD.",
			Optional:    true,
		},
		"roles": {
			Type: schema.TypeList,
			Elem: &schema.Resource{
				Schema: StorageV1ArgoProjectRoleSchema(),
			},
			Description: "Roles is a list of roles that should be attached to the ArgoCD project. If roles are provided no loft default roles will be set. If no roles are provided *and* SSO is enabled, loft will configure sane default values.",
			Optional:    true,
		},
		"source_repos": {
			Type: schema.TypeList,
			Elem: &schema.Schema{
				Type: schema.TypeString,
			},
			Description: "SourceRepos is a list of source repositories to attach/allow on the project, if not specified will be \"*\" indicating all source repositories.",
			Optional:    true,
		},
	}
}

func CreateStorageV1ArgoProjectSpec(data map[string]interface{}) *storagev1.ArgoProjectSpec {
	if !utils.HasKeys(data) {
		return nil
	}

	ret := &storagev1.ArgoProjectSpec{}

	if v, ok := data["enabled"].(bool); ok {
		ret.Enabled = v
	}

	if metadata := CreateStorageV1ArgoProjectSpecMetadata(data["metadata"].(map[string]interface{})); metadata != nil {
		ret.Metadata = *metadata
	}

	var rolesItems []storagev1.ArgoProjectRole
	for _, v := range data["roles"].([]interface{}) {
		item := *CreateStorageV1ArgoProjectRole(v.(map[string]interface{}))
		rolesItems = append(rolesItems, item)
	}
	ret.Roles = rolesItems

	var sourceReposItems []string
	for _, v := range data["source_repos"].([]string) {
		sourceReposItems = append(sourceReposItems, v)
	}
	ret.SourceRepos = sourceReposItems

	return ret
}

func ReadStorageV1ArgoProjectSpec(obj *storagev1.ArgoProjectSpec) (interface{}, error) {
	if obj == nil {
		return nil, nil
	}

	values := map[string]interface{}{}
	values["enabled"] = obj.Enabled

	metadata, err := ReadStorageV1ArgoProjectSpecMetadata(&obj.Metadata)
	if err != nil {
		return nil, err
	}
	values["metadata"] = metadata

	var rolesItems []interface{}
	for _, v := range obj.Roles {
		item, err := ReadStorageV1ArgoProjectRole(&v)
		if err != nil {
			return nil, err
		}
		rolesItems = append(rolesItems, item)
	}
	values["roles"] = rolesItems

	var sourceReposItems []interface{}
	for _, v := range obj.SourceRepos {
		sourceReposItems = append(sourceReposItems, v)
	}

	values["source_repos"] = sourceReposItems

	return values, nil
}
